# Reproducible assets

* Author: oskin1
* Status: Proposed
* Created: 05-Nov-2022
* License: CC0
* Forking: not needed 

## Abstract 

In this document we propose an improvement of [EIP-4](./eip-0004.md) which wraps around existing token standard and adds a way to reissue assets in a programmatic way. 

## Background

In October 2019 EIP-4 was introduced as a mandatory standard describing how to handle on-chain token metadata (name, descr, etc..) consistently. 
However a major limitation was that EIP-4 only covered asset metadata while defaulting the aspect of asset issuance to what bare Ergo protocol offers - one-time emission for each tokenId.

## Motivation

One-time emission limits those projects whose tokenomics assumes non-fixed supply or cross-chain usage of the token (bridges usually require minting and burning when the asset is moved back and forth between diferent chains)

## Reproducible assets

The "one-time emission" constraint follows from the design of token issuance in Ergo: Native ID (`tokenId`) of a token being issued must be equal to `boxId` of the first input of issuing transaction. A rather fortunate consequence of such a design is that it links `tokenId` which is always by hand when we work with the token to that first input. 
A natural solution is to use this detail to build a protocol that would allow to: 
1. link together N different `tokenId`s 
2. trustlessly verify that all those tokens are authorithed by the same entity (wallet, or script).
3. efficiently query proof of authorithation
4. efficiently query emission amount

### EIP-40-Asset-ID

Due to Ergo protocol design implications discussed earlier we can't have reproducible assets that share the same `tokenId`. To bypass this we introduce a synthetic token ID (let's call it EIP-40-Asset-ID). This helps to hide all the added complexity from the end user so managing the asset for them can be as convinient as manging EIP-4 asset.

We define `EIP-40-Asset-ID` of an asset with `tokenId` as `EIP-40-Asset-ID(tokenId) = sha256(Box{boxId=tokenId}.ergoTreeBytes)`, where `Box{boxId=tokenId}` is the first input of the TX that mint the token `tokenId`, let's call it a "PermittingBox".

Anchoring `EIP-40-Asset-ID` to a specific ErgoTree means that we can have something like "Minting Scripts", e.g. controll emission with a script. In the simplest case it can be `ProveDlog` - a proposition of some secret, in most complicated scenarios - a DAO script, which authorizes changing emission (e.g. minting) via voting.

Querying proof of authorization can be done as follows `isAuthed(tokenId) := getBox(boxId=tokenId).isDefined && getUtxo(boxId=tokenId).isEmpty`

In order to simplify the process of querying asset metadata we propose to store it in the PermittingBox. Then asset metadata can be queried as follows `metadata(EIP-40-Asset-ID(tokenId)) = parseEip40Metadata(getBox(boxId=tokenId))`, where `parseEip40Metadata` is a method that extracts all the EIP-4 fields from the given box, plus current circulating supply.

Circulating supply as well as other metadata members is written by permitting entity

Let's define extended registers mapping from EIP-4:

| Register       | SType      | Description                                     | Example                     |
|:--------------:|:----------:|:------------------------------------------------|:----------------------------|
| R2             | Coll[Byte] | Token id and amount pair                        | [("7d...09", 100000)]       |
| R4             | Coll[Byte] | Token verbose name (UTF-8 representation)       | "USD"                       |
| R5             | Coll[Byte] | Token description (UTF-8 representation)        | "Nothing backed USD token"  |
| R6             | Coll[Byte] | Number of decimals                              | "2"                         |
| R7             | BigInt     | Circulating supply                              | 1000000                     |

\* An extension of EIP-4 for NFTs is not relevant here, so we can utilize R7.

Asset metadata is controlled by an entity that permits minting (some party, in the case of simple `ProveDlog` or a script in a more complex cases). Then, circulating supply can be trustlessly checked by executing a query:
```ts
let permittingBoxes     = getBoxes(ergoTreeHash=EIP40AssetID)
let mintingTransactions = permittingBoxes.map(box => getTx(inputsContain=box.id))
let realEmission        = mintingTransactions.map(tx => amountMint(tx)).sum
realEmission == declaredEmission
```
* We assume that `getBoxes(ergoTreeHash=EIP40AssetID)` is implemented via an index `sha256(box.ergoTree)`. Although, other options are possible (i.e using a pre image of `EIP40AssetID`).

### Alternative

An alternative solution to reproducible assets could be to issue max amount of tokens possible in Ergo at once and then lock them on some wallet or smart-contract (vault), declaring the emission as `MaxAmountMint - LockedAmount`. Then minting operation would be equal to unlocking assets from vault and burning operation would be equal to returning coins back to vault. 
The problem is that there is no way to guarantee correctness of burning, unless bundling tokens with some script, what imposes serious comlication on the implementing side (apps, wallets that are going to support such an asset standard).
Without consistent burning there is no way to precisely calculate emission in constant time.
