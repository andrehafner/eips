- Author: anon-br
- Status: Proposed
- Created: 14-March-2022
- Last edited: 14-March-2022
- License: CC0
- Forking: not needed

# Abstract

This EIP proposes a standard for message signing, verification, and representation.

# Motivation

Arbitrary data signing and verifying can cover use cases such as:

- Proving the ownership of a public key;
- Website access control;
- Document and data stamping.

# Requirements

- `R1` - Secure: signing process must prevent known attack vectors;
- `R2` - Verifiable: messages must have verifiable representations;
- `R3` - Hardware wallet-friendly: message representation must be small enough to fit well in hardware wallet devices' screens, and the signing process must be as resource-efficient as possible.

# Encoding

To meet requirements R2 and R3, an encoding scheme becomes necessary. This document proposes an extension of the current Ergo addresses codeset.

Currently, we have the following setup:

- `1`: `P2PK` - Pay to Public Key
- `2`: `P2SH` - Pay to Script Hash
- `3`: `P2S` - Pay to Script

This document proposes a new address type code:

- `4`: `ADH` - Arbitrary Data Hash

Using the hashed data instead of the actual data bytes allows for shorter text representations and meets requirement R3 for representation shortness and resource efficiency.

## Pseudocode implementation

Message encoding follows the same steps as addresses encoding, it mush have a head byte, a body and a checksum.

```ts
const networkCode = 0; // 0 = mainnet, 16 = testnet
const addressCode = 4; // 4 = ADH - Arbitrary Data Hash
const dataHash = blake2b256(dataBytes);

const headByte = [networkCode + addressCode];
const body = concat(headByte, dataHash);
const checksum = blake2b256(body).subarray(0, 4);

const encodedRepresentation = base58(concat(body, checksum));
```

# Signing and Verifying

The data signing and verifying process is done similarly to a regular transaction signing/verifying, basically a prover takes the data bytes and uses a private key to sign it. But sending data bytes directly to the prover can lead to some known security issues, namely:

- `AV1`: A bad actor can steal funds by tricking the user and sending transaction bytes instead of a regular data message to be signed.
- `AV2` - Repay attacks: A bad actor can ask a user to sign a message on the testnet and reuse the signature on the mainnet.

To accomplish `AV1` this document proposes two guardrails on signing and consequently on verifying processes: 1) prover must hash the data bytes and use the hash output to sign/verify instead of using data bytes directly (which will also help with `R3`), and 2) prefix the hash to be signed/verified with a `0x0` byte.

## Why prefix it with `0x0`?

In the current transaction binary serialization format, every transaction should start with a VQL value representing the quantity of inputs the transaction is trying to spent. Knowing that is impossible is impossible to spend a transaction, is safe to assume that a valid serialized transaction will never start with `0x0`. Something similar is done on Ethereum, where every data to be signed/verified must be prefixed with `0x19`[^1].

[^1]: Ethereum EIP-191 specification: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md#specification
